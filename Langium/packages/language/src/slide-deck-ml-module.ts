    import { type Module, inject, IndentationAwareLexer, IndentationAwareTokenBuilder, DefaultValueConverter, GrammarAST, CstNode, ValueType, LangiumDocument, CstUtils, LeafCstNode } from 'langium';
    import { createDefaultModule, createDefaultSharedModule, DefaultCompletionProvider, type DefaultSharedModuleContext, type LangiumServices, type LangiumSharedServices, type PartialLangiumServices } from 'langium/lsp';
    import { SlideDeckMlGeneratedModule, SlideDeckMlGeneratedSharedModule } from './generated/module.js';
    import { SlideDeckMlValidator, registerValidationChecks } from './slide-deck-ml-validator.js';
    import { CompletionList, getCSSLanguageService, TextDocument } from 'vscode-css-languageservice';
    import { CancellationToken } from 'vscode-jsonrpc';
    import { CompletionItemKind, CompletionParams } from 'vscode-languageserver-protocol';
import { CssBlock } from './generated/ast.js';
    

    /**
     * Declaration of custom services - add your own service classes here.
     */
    export type SlideDeckMlAddedServices = {
        validation: {
            SlideDeckMlValidator: SlideDeckMlValidator
        }
    }

    /**
     * Union of Langium default services and your custom services - use this as constructor parameter
     * of custom service classes.
     */
    export type SlideDeckMlServices = LangiumServices & SlideDeckMlAddedServices

    /**
     * Dependency injection module that overrides Langium default services and contributes the
     * declared custom services. The Langium defaults can be partially specified to override only
     * selected services, while the custom services must be fully specified.
     */
    export const SlideDeckMlModule: Module<SlideDeckMlServices, PartialLangiumServices & SlideDeckMlAddedServices> = {
        validation: {
            SlideDeckMlValidator: () => new SlideDeckMlValidator()
        },
        parser: {
            TokenBuilder: () => new IndentationAwareTokenBuilder(),
            Lexer: (services) => new IndentationAwareLexer(services),
            ValueConverter: () => new SlideDeckMlValueConverter(),

        },
        lsp: {
            CompletionProvider: (services) => new CSSCompletionProvider(services)
        }
    };

    /**
     * Create the full set of services required by Langium.
     *
     * First inject the shared services by merging two modules:
     *  - Langium default shared services
     *  - Services generated by langium-cli
     *
     * Then inject the language-specific services by merging three modules:
     *  - Langium default language-specific services
     *  - Services generated by langium-cli
     *  - Services specified in this file
     *
     * @param context Optional module context with the LSP connection
     * @returns An object wrapping the shared services and the language-specific services
     */
    export function createSlideDeckMlServices(context: DefaultSharedModuleContext): {
        shared: LangiumSharedServices,
        SlideDeckMl: SlideDeckMlServices
    } {
        const shared = inject(
            createDefaultSharedModule(context),
            SlideDeckMlGeneratedSharedModule
        );
        const SlideDeckMl = inject(
            createDefaultModule({ shared }),
            SlideDeckMlGeneratedModule,
            SlideDeckMlModule
        );
        shared.ServiceRegistry.register(SlideDeckMl);
        registerValidationChecks(SlideDeckMl);
        if (!context.connection) {
            // We don't run inside a language server
            // Therefore, initialize the configuration provider instantly
            shared.workspace.ConfigurationProvider.initialized({});
        }
        return { shared, SlideDeckMl };
    }

    export class SlideDeckMlValueConverter extends DefaultValueConverter {

        protected override runConverter(
            rule: GrammarAST.AbstractRule,
            input: string,
            cstNode: CstNode
        ): ValueType {

            if (rule.name === 'TEXT_BLOCK') {
                return this.normalizeTextBlock(input);
            }

            return super.runConverter(rule, input, cstNode);
        }

        private normalizeTextBlock(input: string): string {
            // remove ``` fences
            const content = input.slice(3, -3);

            const lines = content.split('\n');

            // trim empty lines at start/end
            while (lines.length && lines[0].trim() === '') lines.shift();
            while (lines.length && lines[lines.length - 1].trim() === '') {
                lines.pop();
            }

            // compute minimal indentation
            const minIndent = Math.min(
                ...lines
                    .filter(l => l.trim().length > 0)
                    .map(l => l.match(/^\s*/)?.[0].length ?? 0)
            );
            return lines.map(l => l.slice(minIndent)).join('\n');
        }
    }

    export class CSSCompletionProvider extends DefaultCompletionProvider {

        private cssService = getCSSLanguageService();

        //creates a in memory css file, text file is contained in a div to show css property completion
        private createVirtualCssDocument(cssText: string) {
            return TextDocument.create(
                'file:///virtual.css',
                'css',
                0,
                `div { \n${cssText}\n }`
            );
        }

        override async getCompletion(
            document: LangiumDocument,
            params: CompletionParams,
            _cancelToken?: CancellationToken
        ): Promise<CompletionList | undefined> {

            const offset = document.textDocument.offsetAt(params.position);
            const nodeInfo = this.getCssNodeAtOffset(document, offset);

            if (!nodeInfo) return;

            const { cssText, cssOffset } = nodeInfo;

            const cssDoc = this.createVirtualCssDocument(cssText);
            const pos = cssDoc.positionAt(cssOffset);

            const stylesheet = this.cssService.parseStylesheet(cssDoc);
            const completions = this.cssService.doComplete(cssDoc, pos, stylesheet);

            return {
                isIncomplete: false,
                items: completions.items.map(item => ({
                    label: item.label,
                    kind: item.kind ?? CompletionItemKind.Property,
                    insertText: item.insertText ?? item.label,
                    detail: item.detail,
                    documentation: item.documentation?.toString()
                }))
            };
        }

        private getCssNodeAtOffset(document: LangiumDocument, offset: number) {
            const rootNode = document.parseResult.value;
            const rootCst = rootNode.$cstNode;
            if (!rootCst) return;

            const leaf: LeafCstNode | undefined = CstUtils.findLeafNodeAtOffset(rootCst, offset);
            if (!leaf) return;

            if (leaf.astNode.$type === 'CssBlock') {
                const container: CssBlock = leaf.astNode as CssBlock;

                if (container.content) {
                    return {
                        cssText: container.content,
                        cssOffset: offset - (leaf.offset)
                    };
                }
            }
            return;
        }
    }